/******************************************************************************
* @file
* Данный файл объявляет и определяет вспомагательные шаблонные классы,
* структуры, функции
*
* @author Bruvamasc
* @date   2022-08-25
*
* @todo ТАААТАТ
* ///< Указывает, что элемент недоступен для использования
*
******************************************************************************/

#ifndef XMLB_TEMPLATES_H
#define XMLB_TEMPLATES_H

namespace XMLB
{
	/**************************************************************************
	* @brief Вернуть категорию итератора
	**************************************************************************/
	template<typename Iter>
	using iterator_category_t = 
		typename std::iterator_traits<Iter>::iterator_category;



	/**************************************************************************
	* @brief Вернуть тип содержимого у итератора
	**************************************************************************/
	template<typename Iter>
	using iterator_value_t = typename std::iterator_traits<Iter>::value_type;



	/**************************************************************************
	* @brief Вернуть тип тип ссылки содержимого у итератора
	**************************************************************************/
	template<typename Iter>
	using iterator_reference_t = 
		typename std::iterator_traits<Iter>::reference;



	/**************************************************************************
	* @brief Есть ли у типа оператор++()
	**************************************************************************/
	template<typename T>
	using is_has_operator_plus_plus = decltype(++std::declval<T&>());



	/**************************************************************************
	* @brief Есть ли у типа оператор*()
	**************************************************************************/
	template<typename T>
	using is_has_operator_indirect_conversion = 
		decltype(*std::declval<Iter&>());



	/**************************************************************************
	* @brief Есть ли у типа оператор==(T)
	**************************************************************************/
	template<typename T>
	using is_has_operator_self_equality = 
		decltype(std::declval<Iter&>().operator==(std::declval<Iter&>()));


	/**************************************************************************
	* @brief Вспомагательная структура, для реализации функции parse_to_node
	* Является деталью реализации!
	**************************************************************************/
	template<typename Iter>
	struct Tag_range_impl final
	{
		Iter first;				//Итератор на начало диапазона
		Iter last;				//Итератор на конец диапазона
		Node::Ptr node;			//XML узел
	};
}

#endif // !XMLB_TEMPLATES_H